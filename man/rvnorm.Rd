% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rvnorm.R
\name{rvnorm}
\alias{rvnorm}
\title{The Variety Normal Distribution}
\usage{
rvnorm(n, poly, sd, output = "simple", chains = 4L,
  warmup = floor(n/2), keep_warmup = FALSE, thin = 1L,
  inject_direct = FALSE, verbose = FALSE,
  cores = getOption("mc.cores", 1L), normalized = TRUE, w, vars,
  numerator, denominator, refresh, ...)
}
\arguments{
\item{n}{The number of draws desired from each chain after warmup.}

\item{poly}{An mpoly object.}

\item{sd}{The "standard deviation" component of the normal kernel.}

\item{output}{\code{"simple"}, \code{"more"}, \code{"stanfit"}.}

\item{chains}{The number of chains to run for the random number generation,
see \code{\link[=stan]{stan()}}.}

\item{warmup}{Number of warmup iterations in \code{\link[=stan]{stan()}}.}

\item{keep_warmup}{If \code{TRUE}, the MCMC warmup steps are included in the
output.}

\item{thin}{\code{\link[=stan]{stan()}} \code{thin} parameter.}

\item{inject_direct}{Directly specify printed polynomial to string inject
into the stan code. Requires you specify \code{vars}, \code{numerator}, and
\code{denominator}.}

\item{verbose}{\code{TRUE} or \code{FALSE}; determines level of messaging.}

\item{cores}{The number of CPU cores to distribute the chains across, see
\code{\link[=stan]{stan()}}.}

\item{normalized}{If \code{TRUE}, the polynomial is gradient-normalized. This
is highly recommended.}

\item{w}{A box window (-w,w) of the same dimension as the number of
variables.}

\item{vars}{A character vector of the indeterminates in the distribution.}

\item{numerator, denominator}{A character(1) containing the printed numerator
of the variety normal distribution.}

\item{refresh}{The \code{refresh} argument of \code{\link[=stan]{stan()}}, which governs how
much information is provided to the user while sampling.}

\item{...}{Additional parameters to pass to \code{\link[=stan]{stan()}}.}
}
\value{
Either (1) matrix whose rows are the individual draws from the
distribution, (2) a \linkS4class{tbl_df} object with the draws along with
additional information, or (3) an object of class \linkS4class{stanfit}.
}
\description{
Un-normalized density function and random generation for the variety normal
distribution with mean equal to \code{poly} and "standard deviation" equal to
\code{sd}. Please see details for caveats.
}
\details{
If the variety you are interested in is connected, this strategy should work
well out of the box.  If it isn't, you'll likely need to rely on running
multiple chains, and it is very likely, if not probable, that the sampling
will be biased to one or more of those components and down-sample others.
Question: what is the relative likelihood of each component, or an equal unit
of length, on different components? How does this generalize to more
varieties of varying dimensions?
}
\examples{

\dontrun{ runs rstan

library("ggplot2")

## basic usage
########################################

p <- mp("x^2 + y^2 - 1")
samps <- rvnorm(2000, p, sd = .1)
head(samps)
str(samps) # 2000 * (4 chains)

(samps <- rvnorm(2000, p, sd = .1, output = "tibble"))
ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()
ggplot(samps, aes(x, y, color = num > 0)) + 
  geom_point(size = .5) + 
  coord_equal()


## using refresh to get more info
########################################

rvnorm(2000, p, sd = .1, "tibble", verbose = TRUE)
rvnorm(2000, p, sd = .1, "tibble", refresh = 100)
rvnorm(2000, p, sd = .1, "tibble", refresh = 500)
rvnorm(2000, p, sd = .1, "tibble", refresh = 0)
rvnorm(2000, p, sd = .1, "tibble", refresh = -1)


## many chains in parallel
########################################

options(mc.cores = parallel::detectCores())
p <- mp("x^2 + (4 y)^2 - 1")
samps <- rvnorm(250, p, sd = .01, "tibble", verbose = TRUE, chains = 8)
ggplot(samps, aes(x, y)) + geom_point() + coord_equal()


## windowing for unbounded varieties
########################################

p <- mp("y^2 - (x^3 + x^2)")
samps <- rvnorm(250, p, sd = .05, "tibble", chains = 8, w = 1.15)
ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()


## the importance of normalizing 
########################################
# one of the effects of the normalizing is to stabilize variances, making 
# them roughly equivalent globally over the variety.

# lemniscate of bernoulli
p <- mp("(x^2 + y^2)^2 - 2 (x^2 - y^2)")

# normalized, good
(samps <- rvnorm(2000, p, .025, "tibble"))
ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()

# unnormalized, bad
(samps <- rvnorm(2000, p, .025, "tibble", normalized = FALSE))
ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()


## semi-algebraic sets
########################################
# inside the semialgebraic set x^2 + y^2 <= 1
# this is the same as x^2 + y^2 - 1 <= 0, so that
# x^2 + y^2 - 1 + s^2 == 0 for some slack variable s
# this is the projection of the sphere into the xy-plane.

p <- mp("1 - (x^2 + y^2) - s^2")
samps <- rvnorm(1e4, p, sd = .01, "tibble", chains = 8)
ggplot(samps, aes(x, y)) + geom_point(size = .5) + coord_equal()
ggplot(samps, aes(x, y)) + geom_bin2d() + coord_equal()

ggplot(sample_n(samps, 2e3), aes(x, y, color = s)) + 
  geom_point(size = .5) + 
  coord_equal()
  
# alternative representation   
# x^2 + y^2 - 1 <= 0 iff s^2 (x^2 + y^2 - 1) == -1
# so that s^2 (x^2 + y^2 - 1) + 1 == 0
# while this strategy works in theory, it doesn't work
# so well in practice, since s^2 is unbounded.
# it's gradient is also more complicated.

## keeping the warmup / the importance of multiple chains
########################################

p <- mp("((x + 1.5)^2 + y^2 - 1) ((x - 1.5)^2 + y^2 - 1)")
ggvariety(p, xlim = c(-3,3)) + coord_equal()

samps <- rvnorm(500, p, sd = .05, "tibble", chains = 8, keep_warmup = TRUE, w = 5)
ggplot(samps, aes(x, y, color = iter)) + 
  geom_point(size = 1, alpha = .5) + geom_path(alpha = .2) + 
  coord_equal() + facet_wrap(~ factor(chain))


## ideal-variety correspondence considerations
########################################

p <- mp("x^2 + y^2 - 1")

samps_1 <- rvnorm(250, p^1, sd = .1, output = "tibble", chains = 8)
samps_2 <- rvnorm(250, p^2, sd = .1, output = "tibble", chains = 8)
samps_3 <- rvnorm(250, p^3, sd = .1, output = "tibble", chains = 8)
samps_4 <- rvnorm(250, p^4, sd = .1, output = "tibble", chains = 8)
samps <- bind_rows(mget(apropos("samps_")))
samps$power <- rep(seq_along(apropos("samps_")), each = 2000)

ggplot(samps, aes(x, y, color = num < 0)) + 
  geom_point(size = .5) + 
  coord_equal(xlim = c(-3,3), ylim = c(-3,3)) +
  facet_wrap(~ power)


}

}
\author{
David Kahle
}
